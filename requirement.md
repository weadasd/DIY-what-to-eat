

你现在是一个资深前端工程师 + UX 设计师，请帮我从零写一个**完整的单文件 Web 应用**，用于「做饭菜单规划 + 购物清单生成」，技术栈限定为：

* 只使用 **原生 HTML + CSS + JavaScript**
* 不使用任何框架（如 React/Vue）、不使用打包工具
* 所有代码写在一个 `index.html` 文件中，包含：

  * `<style>` 里的 CSS
  * `<script>` 里的 JS

目标：
这是一个**个人菜谱 & 每周晚餐规划工具**，用于：

1. 建立我自己的「菜品信息库」
2. 自动生成若干天的午餐/晚餐菜单
3. 支持替换某一天或某道菜
4. 根据菜单生成购物清单（不需要克数，只统计「出现次数」）
5. 所有数据保存在 `localStorage` 中，刷新页面后不丢失

---

## 一、整体 UI 结构（单页应用）

请使用简洁、现代、偏「卡片」风格的设计，适配桌面端与手机端（简单响应式即可）。

页面上用**顶部标签导航**或侧边导航，至少包含 4 个主要模块（可以用 tab 切换）：

1. **「菜库管理」**（Dish Library）
2. **「用餐配置 & 生成菜单」**（Config & Generate）
3. **「本周菜单」**（Weekly Menu）
4. **「购物清单」**（Shopping List）

### 1）顶部导航示例

* 顶部一个横向导航条，包含 4 个按钮：

  * 菜库管理
  * 配置 & 生成
  * 本周菜单
  * 购物清单
* 点击切换时，通过 JS 显示对应的模块内容，其它模块隐藏。

---

## 二、数据模型设计（非常重要，请严格按此实现）

### 1）菜品数据结构 Dish

用 JS 中的对象数组保存：

```js
{
  id: number,                 // 自增 id
  name: string,               // 菜名，如 "西兰花炒虾仁"
  type: string,               // 类别：'荤菜' | '素菜' | '汤' | '拌菜'
  taste: string[],            // 口味标签数组，如 ['清淡', '微辣', '下饭']
  nutritionTags: string[],    // 营养标签数组，如 ['高蛋白', '低脂', '高纤维']
  ingredients: string[],      // 主食材数组（不写克数），如 ['西兰花', '虾仁', '蒜']
  condiments: string[],       // 调味品数组，如 ['盐', '酱油', '食用油']
  cookTimeLevel: string,      // 可选：'简单' | '中等' | '稍复杂'
  remark: string              // 备注，可为空字符串
}
```

注意：
**不需要用量（克数、毫升），只需要列出有哪些食材和调味品**。

菜品数组存入 localStorage，key 例如：`"dishes"`。

### 2）每周用餐配置 WeeklyConfig

用户可以配置每一天是吃午餐/晚餐，每顿几道菜。

请定义一个配置结构类似：

```js
WeeklyConfig = {
  days: [
    {
      name: '周一',
      lunchEnabled: false,
      lunchDishCount: 0,
      dinnerEnabled: true,
      dinnerDishCount: 2
    },
    ...
    {
      name: '周日',
      lunchEnabled: true,
      lunchDishCount: 2,
      dinnerEnabled: true,
      dinnerDishCount: 3
    }
  ]
}
```

该配置也保存在 localStorage，例如 key：`"weeklyConfig"`。

### 3）生成菜单数据结构 WeeklyMenu

生成后的菜单结构类似：

```js
WeeklyMenu = {
  generatedDays: 7, // 生成的天数，比如 3 / 5 / 7
  days: [
    {
      name: '周一',
      lunch: [dishId1, dishId2],   // 如果午餐禁用，则为 null 或 []
      dinner: [dishId3, dishId4]
    },
    ...
  ]
}
```

保存到 localStorage，例如 key：`"weeklyMenu"`。

### 4）购物清单数据结构 ShoppingList（可运行时计算，不必单独存）

在 JS 中用一个结构表示汇总后的数据：

```js
ShoppingList = {
  ingredients: [
    {
      name: '西兰花',
      count: 3,        // 出现次数
      category: '中度保存' // '易保存' | '中度保存' | '易坏'
    },
    ...
  ],
  condiments: [
    {
      name: '酱油',
      count: 5
    },
    ...
  ]
}
```

购物清单可以每次从 `WeeklyMenu` + `dishes` 计算出来即可。

---

## 三、模块 1：菜库管理（CRUD）

在「菜库管理」模块中，实现以下功能：

### 1）菜品列表展示

* 用一个表格或卡片列表展示所有菜品：

  * 菜名
  * 类别（荤菜/素菜/汤/拌菜）
  * 口味标签
  * 营养标签
  * 主要食材（前 3 个可以用逗号显示）
* 每个菜右侧有：

  * 「编辑」按钮
  * 「删除」按钮

### 2）新增 / 编辑菜品表单

表单字段：

* 菜名（文本输入）
* 类别（下拉选择：荤菜 / 素菜 / 汤 / 拌菜）
* 口味标签（多选：

  * 清淡
  * 微辣
  * 辣
  * 香辣
  * 重口
  * 下饭
    多选用多个 checkbox）
* 营养标签（多选：

  * 高蛋白
  * 低脂
  * 低碳水
  * 高膳食纤维）
* 主食材（用一个 textarea 或 input + “添加”按钮方式，最终存成字符串数组）
* 调味品（同上）
* 烹饪难度（简单 / 中等 / 稍复杂，可选）
* 备注（textarea，可为空）

行为要求：

* 点击「新增菜品」按钮 → 打开空白表单。
* 编辑时 → 表单中填入原数据，修改后点击「保存」覆盖。
* 保存时：

  * 校验：菜名必填，类型必选，至少一个食材。
  * 保存到 localStorage。
  * 重新渲染列表。

---

## 四、模块 2：「用餐配置 & 生成菜单」

该模块包含两个部分：
1）每周用餐配置（午/晚餐 & 菜数）
2）菜单生成参数 & 生成按钮

### 1）每周用餐配置 UI

* 展示一张表格，每行一个星期几（周一 ~ 周日）：

  * 「开启午餐」checkbox
  * 午餐菜品数（数字输入，disabled 时不可编辑）
  * 「开启晚餐」checkbox
  * 晚餐菜品数（数字输入）
* 用户修改后点「保存配置」：

  * 将 `WeeklyConfig` 存到 localStorage。

### 2）菜单生成参数区

提供如下控件：

* 「生成天数」下拉：

  * 3天 / 5天 / 7天
* 「整体主题 / 营养侧重点」（单选）：

  * 正常均衡
  * 高蛋白日
  * 低脂日
  * 低碳水日
  * 高膳食纤维日
* 「口味偏好」（可多选）：

  * 不限制
  * 想吃辣一点 / 下饭一点
  * 偏清淡
* 「一些限制选项」（可选实现）：

  * 勾选「本轮避免重复近期常吃的菜」
  * 可以填一个「今天不想吃的食材」简单文本，例如“鸡肉”（可以只简单过滤含该字符串的食材）

一个「生成菜单」按钮，点击后执行：

```js
generateMenu(config)
```

逻辑见后面算法部分。

生成完成后：

* 把结果存入 `WeeklyMenu`
* 自动切换到「本周菜单」 tab 展示

---

## 五、模块 3：「本周菜单」展示 & 替换功能

在这个模块中：

### 1）菜单展示格式

按天展示，例如卡片形式：

* 卡片标题：周一
* 若 lunch 有启用：

  * 「午餐」下面列出该顿的菜名列表
* 「晚餐」同理
* 每道菜后面带一个「换这道」小按钮（例如一个小刷新图标）

### 2）整顿替换（可选）

在每个「午餐」/「晚餐」标题旁边，放一个「替换这顿」按钮。

### 3）替换逻辑 & 弹出框

当用户点击「换这道」或「换这顿」时，弹出一个浮层/对话框，里面包含：

* 替换原因（单选）：

  * 蛋白质太低了 → 优先筛“高蛋白”
  * 太清淡了，想吃辣一点 → 优先筛“辣/微辣/香辣/下饭”
  * 不喜欢这个菜 → 保持原有营养/口味要求，只排除当前菜
  * 想控制碳水 → 优先筛“低碳水”
* 一个「确认替换」按钮

替换行为：

* 如果是替换单道菜：

  * 根据原因重新筛菜库，选出合适候选；
  * 排除当前菜 id；
  * 尽量不重复当天已选的其它菜；
  * 随机选一个替换；
  * 更新 `WeeklyMenu`，存回 localStorage，再重新渲染。
* 如果是替换整顿饭：

  * 按该顿原本需要的菜数重新生成一组；
  * 同样考虑原因 & 不重复 & 荤素搭配。

---

## 六、模块 4：「购物清单」生成 & 展示

该模块在 UI 上只需要一个「生成购物清单」按钮（也可以在菜单生成后自动刷新）。

### 1）购物清单生成逻辑

请编写一个函数，例如：

```js
function buildShoppingList(dishes, weeklyMenu) { ... }
```

逻辑大致如下：

1. 从 `WeeklyMenu.days` 中遍历所有启用的午餐/晚餐，收集所有菜的 id。
2. 根据菜品 id，到 `dishes` 数组中找到对应 Dish。
3. 把所有菜的 `ingredients` 合并到一个数组里，例如 `allIngredients`。
4. 统计每种食材出现的次数：

   * 用一个 `Map` 或对象，例如 `{ '西兰花': 3, '虾仁': 2 }`。
5. 调味品 `condiments` 同理，统计出现次数即可（不分类保存期）。
6. 为每种食材分配一个「保存类别」：

   * 可以在 JS 里写一个简单的映射对象，如：

```js
const ingredientShelfMap = {
  // 易保存
  '大米': '易保存',
  '面条': '易保存',
  '土豆': '易保存',
  '胡萝卜': '易保存',
  '冻鸡胸肉': '易保存',
  '洋葱': '易保存',
  // 中度保存
  '西兰花': '中度保存',
  '香菇': '中度保存',
  '白菜': '中度保存',
  '鸡蛋': '中度保存',
  // 易坏
  '豆芽': '易坏',
  '鲜虾仁': '易坏',
  '嫩豆腐': '易坏',
  // 默认值
};
```

* 如果查不到该食材，就默认归到「中度保存」或「其他」。

7. 最终构建如上定义的 `ShoppingList` 对象。

### 2）购物清单展示 UI

在「购物清单」模块中，以分组形式展示：

* 标题：✅ 建议一次买齐（易保存）

  * 列表：`食材名 × 出现次数`
* 标题：⚠ 建议 1–3 天内买（中度保存）
* 标题：❗ 建议当天买 / 前一晚下单（易坏）
* 再单独列出「调味品」：

  * 例如：「酱油 × 5 次」「盐 × 7 次」

可以在顶部提供一个「复制文本」按钮，将清单整理成纯文本，方便我复制到买菜 APP 里。

---

## 七、菜单生成算法要求（generateMenu）

请实现一个 JS 函数：

```js
function generateMenu(options) { ... }
```

其中 `options` 包含：

* `daysToGenerate`: 3 | 5 | 7
* `theme`: 'balanced' | 'highProtein' | 'lowFat' | 'lowCarb' | 'highFiber'
* `tastePreference`: 'none' | 'spicy' | 'light'
* 其他可选参数：比如不想吃的食材字符串

算法大致逻辑：

1. 从 localStorage 中读取 `dishes` 和 `weeklyConfig`。
2. 根据 `theme` 对菜品进行初步过滤：

   * 高蛋白：`nutritionTags` 包含“高蛋白”的优先；若不足，则放宽标准。
   * 低脂：优先选含“低脂”的菜。
   * 低碳水：优先选含“低碳水”的菜。
   * 高纤维：优先选含“高膳食纤维”的菜。
   * 正常均衡：不过滤营养标签。
3. 根据 `tastePreference` 再次过滤/排序：

   * 想吃辣：优先选择 `taste` 中包含「微辣/辣/香辣/下饭」的菜。
   * 清淡：优先选择 `taste` 中只有「清淡」或无辣标签的菜。
4. 根据 `WeeklyConfig` 的每一天数据，生成对应天的 lunch/dinner：

   * 对于某一顿要求 N 道菜：

     * 至少 1 道素菜（type='素菜'）；
     * 其他菜可以是荤菜/素菜/汤/拌菜；
     * 不要全是汤；
   * 如果候选中不够素菜，则放宽规则。
5. 避免重复：

   * 同一道菜在本轮生成中尽量不要在相邻两天重复；
   * 同一天中不出现重复 id；
   * 可简单记录本轮已使用的菜 id 做排除。
6. 将生成结果写入 `WeeklyMenu` 并存入 localStorage。

---

## 八、代码结构要求

请将 JS 代码结构化，避免一团乱麻：

* 数据读写：

  * `loadDishes() / saveDishes()`
  * `loadWeeklyConfig() / saveWeeklyConfig()`
  * `loadWeeklyMenu() / saveWeeklyMenu()`
* 渲染函数：

  * `renderDishList()`
  * `renderWeeklyConfig()`
  * `renderWeeklyMenu()`
  * `renderShoppingList()`
* 逻辑函数：

  * `generateMenu(options)`
  * `replaceDish(dayIndex, mealType, dishIndex, reason)`
  * `replaceMeal(dayIndex, mealType, reason)`
  * `buildShoppingList(dishes, weeklyMenu)`

请注意：

* 页面加载时：

  * 初始化 localStorage（如果没有默认数据，可以预置 3~5 个示例菜）。
  * 渲染各个模块默认视图。
* 所有按钮都要绑定清晰的事件监听。

---

## 九、UI/交互细节小要求

* 整体配色尽量清爽一点，可以用浅灰 + 一种主色（如蓝/绿色），不用太花哨。
* 表单与按钮有 hover 效果。
* 操作成功后（如保存菜品、生成菜单、替换成功等）可以使用简单的「toast 提示条」在右上角或顶部短暂显示文字：“保存成功”，“菜单已生成”等。
* 对用户操作做一些基础校验，防止空数据导致报错。

